using System.Reflection;
using System.Text;

namespace Luna.Generators;

/// <summary> A string builder that keeps track of indentation levels and provides some utility methods for code generation. </summary>
public class IndentedStringBuilder
{
    private const string BaseIndentation = "    ";

    private readonly StringBuilder _sb          = new();
    private          string        _indentation = string.Empty;

    /// <summary> Increase the indentation level by 1 without moving the cursor. </summary>
    public IndentedStringBuilder Indent()
    {
        _indentation = $"{_indentation}{BaseIndentation}";
        return this;
    }

    /// <summary> Decrease the indentation level by 1 and also reduce the current cursor position by one indentation level. </summary>
    public IndentedStringBuilder Unindent()
    {
        _indentation =  _indentation.Substring(BaseIndentation.Length);
        _sb.Length   -= BaseIndentation.Length;
        return this;
    }

    /// <summary> Append an empty line. </summary>
    public IndentedStringBuilder AppendLine()
    {
        _sb.AppendLine().Append(_indentation);
        return this;
    }

    /// <summary> Append the given text and add a line break. </summary>
    public IndentedStringBuilder AppendLine(string text)
    {
        _sb.AppendLine(text).Append(_indentation);
        return this;
    }

    /// <summary> Append the given symbol and add a line break. </summary>
    public IndentedStringBuilder AppendLine(char symbol)
    {
        _sb.Append(symbol).AppendLine().Append(_indentation);
        return this;
    }

    /// <summary> Append the given text. </summary>
    public IndentedStringBuilder Append(string text)
    {
        _sb.Append(text);
        return this;
    }

    /// <summary> Append the given symbol. </summary>
    public IndentedStringBuilder Append(char symbol)
    {
        _sb.Append(symbol);
        return this;
    }

    /// <summary> Open a block with a '{', add one indentation level and jump to the next line. </summary>
    public IndentedStringBuilder OpenBlock()
        => Append('{').Indent().AppendLine();

    /// <summary> Remove the indentation level by 1 and move the cursor back accordingly, then append a '}' without adding a line-break. </summary>
    public IndentedStringBuilder CloseBlock()
        => Unindent().Append('}');

    /// <summary> Create a default preamble for generated code. </summary>
    public static IndentedStringBuilder CreatePreamble()
        => new IndentedStringBuilder().AppendLine("using System;").AppendLine("using System.CodeDom.Compiler;").AppendLine()
            .AppendLine("#nullable enable").AppendLine();

    /// <summary> Open a namespace with a block only if the passed namespace name is not empty. </summary>
    public IndentedStringBuilder OpenNamespace(string @namespace)
    {
        if (@namespace.Length is 0)
            return this;

        return Append("namespace ").Append(@namespace).AppendLine().OpenBlock();
    }

    /// <summary> Close all blocks based on indentation level. </summary>
    public IndentedStringBuilder CloseAllBlocks()
    {
        while (_indentation.Length > 0)
            CloseBlock().AppendLine();
        return AppendLine();
    }

    /// <inheritdoc/>
    public override string ToString()
        => _sb.ToString();

    /// <summary> Open a public, static, partial class of the given name. </summary>
    public IndentedStringBuilder OpenExtensionClass(string @class)
    {
        var dot = @class.LastIndexOf('.');
        if (dot >= 0)
            @class = @class.Substring(dot + 1);
        return Append("public static partial class ").Append(@class).AppendLine().OpenBlock();
    }

    /// <summary> Append an object with a full namespace definition and a `global::` tag. </summary>
    public IndentedStringBuilder AppendObject(string name, string @namespace = "")
    {
        if (!SimpleAlias(name))
        {
            Append("global::");
            if (@namespace.Length > 0)
                Append(@namespace).Append('.');
        }

        return Append(name);
    }

    /// <summary> Add an attribute that the given code was generated by this assembly. </summary>
    public IndentedStringBuilder GeneratedAttribute()
    {
        var assemblyName = Assembly.GetAssembly(typeof(IndentedStringBuilder)).GetName();
        return AppendLine($"[GeneratedCode(\"{assemblyName.Name}\", \"{assemblyName.Version}\")]");
    }

    /// <summary> Append a full comparison or equality operator method. </summary>
    /// <param name="operator"> The operator to use, e.g. '=='. </param>
    /// <param name="lhsType"> The name of the type on the left side. </param>
    /// <param name="rhsType"> The name of the type on the right side. </param>
    /// <param name="lhsValue"> The field name of the type on the left side, if empty the left side will be compared itself. </param>
    /// <param name="rhsValue"> The field name of the type on the right side, if empty the right side will be compared itself. </param>
    /// <param name="priority"> The overload resolution priority. Omitted if 0. </param>
    public IndentedStringBuilder AppendComparisonOperator(string @operator, string lhsType, string rhsType, string lhsValue, string rhsValue,
        int priority = 0)
    {
        if (priority is not 0)
            AppendLine($"[global::System.Runtime.CompilerServices.OverloadResolutionPriority({priority})]");
        return GeneratedAttribute()
            .Append("public static bool operator ").Append(@operator).Append('(').Append(lhsType).Append(" lhs, ").Append(rhsType)
            .AppendLine(" rhs)")
            .Append("    => lhs").AppendIfNonEmpty(lhsValue, ".").Append(' ').Append(@operator).Append(" rhs").AppendIfNonEmpty(rhsValue, ".")
            .AppendLine(';');
    }

    /// <summary> Append a full arithmetic operator method. </summary>
    /// <param name="operator"> The operator to use, e.g. '+'. </param>
    /// <param name="returnType"> The name of the returned type. </param>
    /// <param name="lhsType"> The name of the type on the left side. </param>
    /// <param name="rhsType"> The name of the type on the right side. </param>
    /// <param name="lhsValue"> The field name of the type on the left side, if empty the left side will be compared itself. </param>
    /// <param name="rhsValue"> The field name of the type on the right side, if empty the right side will be compared itself. </param>
    public IndentedStringBuilder AppendArithmeticOperator(string @operator, string returnType, string lhsType, string rhsType, string lhsValue,
        string rhsValue)
        => GeneratedAttribute()
            .Append("public static ").Append(returnType).Append(" operator ").Append(@operator).Append('(').Append(lhsType).Append(" lhs, ")
            .Append(rhsType)
            .AppendLine(" rhs)")
            .Append("    => new((").Append(returnType).Append(") (lhs").AppendIfNonEmpty(lhsValue, ".").Append(' ').Append(@operator).Append(" rhs").AppendIfNonEmpty(rhsValue, ".")
            .AppendLine("));");

    private IndentedStringBuilder AppendIfNonEmpty(string text, string pre = "", string post = "")
        => text.Length > 0 ? Append(pre).Append(text).Append(post) : this;

    public static bool SimpleAlias(string name)
        => name switch
        {
            "sbyte"   => true,
            "byte"    => true,
            "short"   => true,
            "ushort"  => true,
            "int"     => true,
            "uint"    => true,
            "long"    => true,
            "ulong"   => true,
            "string"  => true,
            "nint"    => true,
            "nuint"   => true,
            "object"  => true,
            "float"   => true,
            "double"  => true,
            "bool"    => true,
            "decimal" => true,
            "char"    => true,
            _         => false,
        };
}
